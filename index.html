<!DOCTYPE html>
<html lang="ja">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>GlowAdder-MIL | 全加算回路（伝搬可視化）</title>

    <style>
      :root {
        --bg: #0b1220;
        --text: #e8eefc;
        --muted: #b7c3e6;
        --line: rgba(255, 255, 255, 0.12);

        --sum: #8ab4ff; /* Sum系 */
        --carry: #7ee787; /* Carry系 */

        --wire: rgba(255, 255, 255, 0.3);
        --gateStroke: rgba(255, 255, 255, 0.34);
        --gateFill: rgba(16, 26, 48, 0.9);
      }

      body {
        margin: 0;
        font-family: system-ui, -apple-system, "Segoe UI", Roboto,
          "Hiragino Kaku Gothic ProN", "Noto Sans JP", sans-serif;
        background: radial-gradient(1000px 600px at 20% 0%, #17264a, var(--bg));
        color: var(--text);
      }

      header {
        max-width: 980px;
        margin: 0 auto;
        padding: 20px 16px 8px;
      }

      h1 {
        margin: 0 0 6px;
        font-size: 20px;
      }
      p {
        margin: 0;
        color: var(--muted);
        font-size: 14px;
        line-height: 1.6;
      }

      main {
        max-width: 980px;
        margin: 0 auto;
        padding: 12px 16px 28px;
        display: grid;
        grid-template-columns: 360px 1fr;
        gap: 12px;
      }
      @media (max-width: 860px) {
        main {
          grid-template-columns: 1fr;
        }
      }

      .card {
        background: rgba(16, 26, 48, 0.88);
        border: 1px solid var(--line);
        border-radius: 12px;
        padding: 14px;
        backdrop-filter: blur(8px);
      }
      .card h2 {
        margin: 0 0 10px;
        font-size: 16px;
      }

      .box {
        border: 1px solid var(--line);
        border-radius: 10px;
        padding: 10px;
        background: rgba(0, 0, 0, 0.12);
      }
      .box h3 {
        margin: 0 0 10px;
        font-size: 13px;
        color: var(--muted);
        letter-spacing: 0.02em;
      }

      .sw {
        display: grid;
        grid-template-columns: 40px 1fr;
        gap: 10px;
        align-items: center;
        padding: 8px;
        border-radius: 10px;
        border: 1px solid var(--line);
        background: rgba(255, 255, 255, 0.04);
        margin-bottom: 8px;
      }
      .sw:last-child {
        margin-bottom: 0;
      }
      .sw label {
        font-size: 14px;
        color: var(--text);
      }

      .pill {
        width: 40px;
        height: 26px;
        border-radius: 999px;
        background: rgba(255, 255, 255, 0.12);
        border: 1px solid var(--line);
        position: relative;
        cursor: pointer;
        display: inline-block;
      }
      .pill::after {
        content: "";
        position: absolute;
        top: 3px;
        left: 3px;
        width: 18px;
        height: 18px;
        border-radius: 50%;
        background: rgba(255, 255, 255, 0.75);
        transition: transform 0.18s ease;
      }
      input[type="checkbox"] {
        display: none;
      }
      input[type="checkbox"]:checked + .pill {
        background: rgba(138, 180, 255, 0.22);
        border-color: rgba(138, 180, 255, 0.45);
      }
      input[type="checkbox"]:checked + .pill::after {
        transform: translateX(14px);
        background: var(--sum);
      }

      .out {
        display: grid;
        grid-template-columns: 1fr auto;
        gap: 8px;
        align-items: center;
        padding: 10px;
        border-radius: 10px;
        border: 1px solid var(--line);
        background: rgba(255, 255, 255, 0.04);
        margin-bottom: 8px;
      }
      .out:last-child {
        margin-bottom: 0;
      }

      .badge {
        min-width: 44px;
        text-align: center;
        padding: 6px 10px;
        border-radius: 10px;
        font-weight: 700;
        letter-spacing: 0.04em;
        border: 1px solid var(--line);
        background: rgba(0, 0, 0, 0.18);
        color: rgba(255, 255, 255, 0.85);
      }
      .badge.on.sum {
        border-color: rgba(138, 180, 255, 0.55);
        background: rgba(138, 180, 255, 0.12);
        color: var(--sum);
      }
      .badge.on.carry {
        border-color: rgba(126, 231, 135, 0.55);
        background: rgba(126, 231, 135, 0.12);
        color: var(--carry);
      }

      button {
        border: 1px solid var(--line);
        background: rgba(255, 255, 255, 0.06);
        color: var(--text);
        padding: 8px 10px;
        border-radius: 10px;
        cursor: pointer;
        font-size: 13px;
      }
      button:hover {
        background: rgba(255, 255, 255, 0.1);
      }
      button:active {
        transform: translateY(1px);
      }

      .kv {
        display: grid;
        grid-template-columns: 1fr auto;
        gap: 8px;
        align-items: center;
        padding: 8px 10px;
        border-radius: 10px;
        border: 1px dashed rgba(255, 255, 255, 0.16);
        margin-top: 10px;
        color: var(--muted);
        font-size: 13px;
      }
      code {
        font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;
        font-size: 12.5px;
        color: #eaf2ff;
      }

      .diagramWrap {
        border: 1px solid var(--line);
        border-radius: 12px;
        background: rgba(0, 0, 0, 0.1);
        padding: 10px;
        overflow: hidden;
        margin-bottom: 12px;
      }
      .diagramTitle {
        display: flex;
        justify-content: space-between;
        align-items: baseline;
        gap: 10px;
        margin: 0 0 8px;
      }
      .diagramTitle h3 {
        margin: 0;
        font-size: 14px;
      }
      .diagramTitle .hint {
        margin: 0;
        font-size: 12px;
        color: var(--muted);
      }

      svg text {
        fill: rgba(232, 238, 252, 0.92);
        font-family: system-ui, -apple-system, "Segoe UI", Roboto,
          "Noto Sans JP", sans-serif;
      }

      /* ゲート */
      .gate-outline {
        fill: var(--gateFill);
        stroke: var(--gateStroke);
        stroke-width: 1.6;
        stroke-linejoin: round;
      }
      .gate-inner {
        stroke: rgba(255, 255, 255, 0.22);
        stroke-width: 1.2;
        fill: none;
        stroke-linecap: round;
      }

      /* 配線 */
      .wire {
        stroke: var(--wire);
        stroke-width: 3.2;
        fill: none;
        stroke-linecap: round;
        stroke-linejoin: round;
      }

      /* ノード */
      .dot {
        fill: rgba(255, 255, 255, 0.4);
      }

      /* ONの発光 */
      .wire.sum.on {
        stroke: var(--sum);
        filter: drop-shadow(0 0 6px rgba(138, 180, 255, 0.55));
        stroke-opacity: 1;
      }
      .wire.carry.on {
        stroke: var(--carry);
        filter: drop-shadow(0 0 7px rgba(126, 231, 135, 0.55));
        stroke-opacity: 1;
      }
      .dot.sum.on {
        fill: var(--sum);
        filter: drop-shadow(0 0 6px rgba(138, 180, 255, 0.55));
      }
      .dot.carry.on {
        fill: var(--carry);
        filter: drop-shadow(0 0 7px rgba(126, 231, 135, 0.55));
      }

      /* フェード（OFF時だけ薄く見せたい） */
      .fadeMid {
        stroke-opacity: 0.4;
      }

      /* ONのときは fadeMid の薄さを打ち消す（濃淡解消） */
      .wire.on.fadeMid {
        stroke-opacity: 1;
      }

      /* ステップでゲートを強調（枠ハイライト） */
      .gateGroup .gate-outline {
        transition: stroke 0.15s ease, filter 0.15s ease;
      }
      .gateGroup.active .gate-outline {
        stroke: rgba(255, 255, 255, 0.75);
        filter: drop-shadow(0 0 10px rgba(138, 180, 255, 0.25));
      }

      /* 今見ている信号のカーソル（流れる点） */
      .flowDot {
        opacity: 0;
        transition: opacity 0.12s ease;
        filter: drop-shadow(0 0 8px rgba(255, 255, 255, 0.28));
      }
      .flowDot.on {
        opacity: 1;
      }

      /* ゲート遅延UI */
      .delayGrid {
        display: grid;
        grid-template-columns: 1fr;
        gap: 8px;
      }
      .delayRow {
        display: grid;
        grid-template-columns: 72px 1fr 52px;
        gap: 10px;
        align-items: center;
        padding: 8px 10px;
        border-radius: 10px;
        border: 1px solid var(--line);
        background: rgba(255, 255, 255, 0.04);
      }
      .delayRow span {
        color: var(--muted);
        font-size: 12px;
      }
      .delayRow input[type="range"] {
        width: 100%;
      }

      table {
        width: 100%;
        border-collapse: collapse;
        overflow: hidden;
        border-radius: 12px;
        border: 1px solid var(--line);
        background: rgba(0, 0, 0, 0.12);
        font-size: 13px;
      }
      th,
      td {
        padding: 10px;
        border-bottom: 1px solid var(--line);
        text-align: center;
      }
      th {
        color: var(--muted);
        font-weight: 600;
        background: rgba(255, 255, 255, 0.04);
      }
      tr:last-child td {
        border-bottom: 0;
      }
      tr.active td {
        background: rgba(138, 180, 255, 0.12);
        border-bottom-color: rgba(138, 180, 255, 0.25);
      }
    </style>
  </head>

  <body>
    <header>
      <h1>GlowAdder-MIL</h1>
      <p>
        全加算回路（Full
        Adder）を、ANSI/IEEE（通称MIL）系の論理記号（XOR/AND/OR）で表示。<br />
        伝搬（入力→中間→出力）をステップ実行／自動再生で確認できます。
      </p>
    </header>

    <main>
      <!-- 左：入力/出力 -->
      <section class="card">
        <h2>入力 / 出力</h2>

        <div class="box">
          <h3>入力</h3>

          <div class="sw">
            <label for="A">A</label>
            <div>
              <input id="A" type="checkbox" />
              <label class="pill" for="A" aria-label="A切替"></label>
            </div>
          </div>

          <div class="sw">
            <label for="B">B</label>
            <div>
              <input id="B" type="checkbox" />
              <label class="pill" for="B" aria-label="B切替"></label>
            </div>
          </div>

          <div class="sw">
            <label for="Cin">Cin</label>
            <div>
              <input id="Cin" type="checkbox" />
              <label class="pill" for="Cin" aria-label="Cin切替"></label>
            </div>
          </div>

          <div class="kv">
            <div>現在の入力（2進）</div>
            <div><code id="binIn">A B Cin = 0 0 0</code></div>
          </div>
        </div>

        <div class="box" style="margin-top: 10px">
          <h3>出力</h3>
          <div class="out">
            <div>Sum</div>
            <div class="badge" id="SumBadge">0</div>
          </div>
          <div class="out">
            <div>Cout</div>
            <div class="badge" id="CoutBadge">0</div>
          </div>
          <div class="kv">
            <div>合計（A + B + Cin）</div>
            <div><code id="decSum">0</code></div>
          </div>
        </div>

        <div class="box" style="margin-top: 10px">
          <h3>伝搬（Propagation）</h3>

          <div style="display: flex; gap: 8px; flex-wrap: wrap">
            <button id="btnStep" type="button">次へ（伝搬）</button>
            <button id="btnPlay" type="button">再生</button>
            <button id="btnStop" type="button">停止</button>
            <button id="btnReset" type="button">リセット</button>
          </div>

          <div style="margin-top: 10px">
            <div
              style="color: var(--muted); font-size: 12.5px; margin-bottom: 6px"
            >
              ゲート別遅延（ms）
            </div>
            <div class="delayGrid">
              <div class="delayRow">
                <span>XOR1</span>
                <input
                  id="dXOR1"
                  type="range"
                  min="0"
                  max="800"
                  step="50"
                  value="200"
                />
                <code id="dXOR1v">200</code>
              </div>
              <div class="delayRow">
                <span>AND1</span>
                <input
                  id="dAND1"
                  type="range"
                  min="0"
                  max="800"
                  step="50"
                  value="200"
                />
                <code id="dAND1v">200</code>
              </div>
              <div class="delayRow">
                <span>XOR2</span>
                <input
                  id="dXOR2"
                  type="range"
                  min="0"
                  max="800"
                  step="50"
                  value="200"
                />
                <code id="dXOR2v">200</code>
              </div>
              <div class="delayRow">
                <span>AND2</span>
                <input
                  id="dAND2"
                  type="range"
                  min="0"
                  max="800"
                  step="50"
                  value="200"
                />
                <code id="dAND2v">200</code>
              </div>
              <div class="delayRow">
                <span>OR</span>
                <input
                  id="dOR"
                  type="range"
                  min="0"
                  max="800"
                  step="50"
                  value="200"
                />
                <code id="dORv">200</code>
              </div>
            </div>
          </div>

          <div
            style="
              margin-top: 10px;
              color: var(--muted);
              font-size: 12.5px;
              line-height: 1.8;
            "
          >
            全体遅延（予備）：<span id="delayLabel">400</span>ms<br />
            <input
              id="delayMs"
              type="range"
              min="100"
              max="1200"
              step="100"
              value="400"
              style="width: 100%"
            />
            ステップ：<code id="propStep">0</code>（0:入力 / 1:HA1 / 2:HA2 /
            3:OR）
          </div>
        </div>
      </section>

      <!-- 右：回路図＋真理値表 -->
      <section class="card">
        <h2>回路図（MIL/ANSI系 記号）</h2>

        <div class="diagramWrap">
          <div class="diagramTitle">
            <h3>XOR + XOR → Sum / AND + AND → OR → Cout（Full Adder）</h3>
            <p class="hint">青：Sum系 / 緑：Carry系</p>
          </div>

          <svg
            viewBox="0 0 860 260"
            width="100%"
            height="auto"
            aria-label="全加算回路（MIL/ANSI系）"
          >
            <defs>
              <!-- AND: 幅60 高さ60（出力x=+60） -->
              <g id="GATE_AND">
                <path
                  class="gate-outline"
                  d="M0,0 L30,0
                   A30,30 0 0 1 30,60
                   L0,60 Z"
                />
              </g>

              <!-- OR: 左端を x=0 にして、入力線が途切れないようにする -->
              <g id="GATE_OR">
                <path
                  class="gate-outline"
                  d="M0,0
                   C24,0 50,12 74,30
                   C50,48 24,60 0,60
                   C14,44 14,16 0,0
                   Z"
                />
                <path class="gate-inner" d="M-8,8 C6,22 6,38 -8,52" />
              </g>

              <!-- XOR: OR + extra curve（さらにもう1本左カーブ） -->
              <g id="GATE_XOR">
                <path class="gate-inner" d="M-16,8 C-2,22 -2,38 -16,52" />
                <use href="#GATE_OR" />
              </g>
            </defs>

            <!-- ラベル -->
            <text x="30" y="70" font-size="13">A</text>
            <text x="30" y="90" font-size="13">B</text>
            <text x="25" y="205" font-size="13">Cin</text>

            <text x="830" y="120" font-size="13">Sum</text>
            <text x="830" y="160" font-size="13">Cout</text>

            <!-- ===== 配線（先に描く） ===== -->
            <!-- 入力ノード -->
            <circle id="dA" class="dot sum" cx="60" cy="65" r="4"></circle>
            <circle id="dB" class="dot sum" cx="60" cy="85" r="4"></circle>
            <circle id="dCin" class="dot sum" cx="60" cy="200" r="4"></circle>

            <!-- A 分岐（XOR1/AND1） -->
            <path id="wA_L" class="wire sum" d="M60 65 L150 65"></path>
            <path id="wA_R" class="wire sum" d="M150 65 L200 65"></path>
            <path
              id="wA_to_AND1"
              class="wire sum fadeMid"
              d="M150 65 L150 175 L200 175"
            ></path>
            <circle id="jA" class="dot sum" cx="150" cy="65" r="3"></circle>

            <!-- B 分岐（XOR1/AND1） -->
            <path id="wB_L" class="wire sum" d="M60 85 L160 85"></path>
            <path id="wB_R" class="wire sum" d="M160 85 L200 85"></path>
            <path
              id="wB_to_AND1"
              class="wire sum fadeMid"
              d="M160 85 L160 195 L200 195"
            ></path>
            <circle id="jB" class="dot sum" cx="160" cy="85" r="3"></circle>

            <!-- Cin 分岐（XOR2/AND2） -->
            <path id="wCin" class="wire sum" d="M60 200 L360 200"></path>
            <path
              id="wCin_to_XOR2"
              class="wire sum fadeMid"
              d="M360 200 L360 125 L440 125"
            ></path>
            <path
              id="wCin_to_AND2"
              class="wire sum fadeMid"
              d="M360 200 L360 195 L440 195"
            ></path>

            <!-- S1（XOR1出力） -->
            <path id="wS1" class="wire sum" d="M274 75 L330 75"></path>
            <circle id="dS1" class="dot sum" cx="274" cy="75" r="4"></circle>
            <path
              id="wS1_to_XOR2"
              class="wire sum fadeMid"
              d="M330 75 L330 105 L440 105"
            ></path>
            <path
              id="wS1_to_AND2"
              class="wire sum fadeMid"
              d="M330 75 L330 175 L440 175"
            ></path>

            <!-- C1（AND1出力） -> OR in1（AND2を避けて上側へ迂回） -->
            <path
              id="wC1"
              class="wire carry"
              d="M260 185 L340 185 L340 145 L610 145 L660 140"
            ></path>
            <circle id="dC1" class="dot carry" cx="260" cy="185" r="4"></circle>

            <!-- Sum（XOR2出力） -->
            <path id="wSum" class="wire sum" d="M514 115 L820 115"></path>
            <circle id="dSum" class="dot sum" cx="514" cy="115" r="4"></circle>

            <!-- C2（AND2出力） -> OR in2 -->
            <path
              id="wC2"
              class="wire carry"
              d="M500 185 L620 185 L660 160"
            ></path>
            <circle id="dC2" class="dot carry" cx="500" cy="185" r="4"></circle>

            <!-- Cout（OR出力） -->
            <path id="wCout" class="wire carry" d="M734 150 L820 150"></path>
            <circle
              id="dCout"
              class="dot carry"
              cx="734"
              cy="150"
              r="4"
            ></circle>

            <!-- ===== ゲート（最後に描いて配線を自然に隠す） ===== -->
            <g id="G_XOR1" class="gateGroup">
              <use href="#GATE_XOR" transform="translate(200 45)" />
              <text x="237" y="78" text-anchor="middle" font-size="12">
                XOR
              </text>
            </g>

            <g id="G_AND1" class="gateGroup">
              <use href="#GATE_AND" transform="translate(200 155)" />
              <text x="230" y="190" text-anchor="middle" font-size="12">
                AND
              </text>
            </g>

            <g id="G_XOR2" class="gateGroup">
              <use href="#GATE_XOR" transform="translate(440 85)" />
              <text x="477" y="118" text-anchor="middle" font-size="12">
                XOR
              </text>
            </g>

            <g id="G_AND2" class="gateGroup">
              <use href="#GATE_AND" transform="translate(440 155)" />
              <text x="470" y="190" text-anchor="middle" font-size="12">
                AND
              </text>
            </g>

            <g id="G_OR" class="gateGroup">
              <use href="#GATE_OR" transform="translate(660 120)" />
              <text x="697" y="153" text-anchor="middle" font-size="12">
                OR
              </text>
            </g>

            <!-- “今見ている信号”カーソル -->
            <circle id="flow0" class="flowDot" cx="140" cy="65" r="4"></circle>
            <circle id="flow1" class="flowDot" cx="300" cy="75" r="4"></circle>
            <circle id="flow2" class="flowDot" cx="500" cy="115" r="4"></circle>
            <circle id="flow3" class="flowDot" cx="710" cy="150" r="4"></circle>

            <!-- 補助 -->
            <text x="220" y="242" font-size="12" fill="rgba(183,195,230,.9)">
              S1 = A ⊕ B / C1 = A ∧ B / C2 = S1 ∧ Cin
            </text>
          </svg>
        </div>

        <h2>真理値表（該当行をハイライト）</h2>
        <table aria-label="全加算回路の真理値表">
          <thead>
            <tr>
              <th>A</th>
              <th>B</th>
              <th>Cin</th>
              <th>Sum</th>
              <th>Cout</th>
              <th>A+B+Cin</th>
            </tr>
          </thead>
          <tbody id="ttBody"></tbody>
        </table>
      </section>
    </main>

    <script>
      // ===== ロジック =====
      const xor = (a, b) => (a ^ b) & 1;
      const and = (a, b) => a & b & 1;
      const or = (a, b) => (a | b) & 1;

      function fullAdderByStructure(A, B, Cin) {
        const S1 = xor(A, B);
        const C1 = and(A, B);
        const Sum = xor(S1, Cin);
        const C2 = and(S1, Cin);
        const Cout = or(C1, C2);
        return { S1, C1, Sum, C2, Cout };
      }

      // ===== DOM =====
      const elA = document.getElementById("A");
      const elB = document.getElementById("B");
      const elCin = document.getElementById("Cin");

      const binIn = document.getElementById("binIn");
      const decSum = document.getElementById("decSum");

      const sumBadge = document.getElementById("SumBadge");
      const coutBadge = document.getElementById("CoutBadge");

      // 伝搬UI
      const btnStep = document.getElementById("btnStep");
      const btnPlay = document.getElementById("btnPlay");
      const btnStop = document.getElementById("btnStop");
      const btnReset = document.getElementById("btnReset");
      const delayMs = document.getElementById("delayMs");
      const delayLabel = document.getElementById("delayLabel");
      const propStepLabel = document.getElementById("propStep");

      // 真理値表
      const ttBody = document.getElementById("ttBody");

      // --- ゲートのDOM（ハイライト用） ---
      const gateEls = {
        XOR1: document.getElementById("G_XOR1"),
        AND1: document.getElementById("G_AND1"),
        XOR2: document.getElementById("G_XOR2"),
        AND2: document.getElementById("G_AND2"),
        OR: document.getElementById("G_OR"),
      };

      // --- flowDot（カーソル） ---
      const flowDots = [
        document.getElementById("flow0"),
        document.getElementById("flow1"),
        document.getElementById("flow2"),
        document.getElementById("flow3"),
      ];

      function setActiveGate(name) {
        Object.values(gateEls).forEach((g) => g?.classList.remove("active"));
        if (name && gateEls[name]) gateEls[name].classList.add("active");
      }
      function setFlowDot(step) {
        flowDots.forEach((d) => d?.classList.remove("on"));
        if (step >= 0 && step < flowDots.length)
          flowDots[step]?.classList.add("on");
      }

      // --- ゲート別遅延 ---
      const dXOR1 = document.getElementById("dXOR1");
      const dAND1 = document.getElementById("dAND1");
      const dXOR2 = document.getElementById("dXOR2");
      const dAND2 = document.getElementById("dAND2");
      const dOR = document.getElementById("dOR");

      const dXOR1v = document.getElementById("dXOR1v");
      const dAND1v = document.getElementById("dAND1v");
      const dXOR2v = document.getElementById("dXOR2v");
      const dAND2v = document.getElementById("dAND2v");
      const dORv = document.getElementById("dORv");

      function bindDelay(rangeEl, valueEl) {
        const sync = () => (valueEl.textContent = String(rangeEl.value));
        rangeEl.addEventListener("input", sync);
        sync();
      }
      bindDelay(dXOR1, dXOR1v);
      bindDelay(dAND1, dAND1v);
      bindDelay(dXOR2, dXOR2v);
      bindDelay(dAND2, dAND2v);
      bindDelay(dOR, dORv);

      function gateDelayMsForStep(step) {
        // step: 0入力 / 1HA1 / 2HA2 / 3OR
        if (step === 1)
          return Math.max(Number(dXOR1.value), Number(dAND1.value));
        if (step === 2)
          return Math.max(Number(dXOR2.value), Number(dAND2.value));
        if (step === 3) return Number(dOR.value);
        return 0;
      }

      // SVG wires + dots（分岐線も含めてON/OFFする）
      const wires = {
        A: [
          document.getElementById("wA_L"),
          document.getElementById("wA_R"),
          document.getElementById("wA_to_AND1"),
          document.getElementById("dA"),
          document.getElementById("jA"),
        ],
        B: [
          document.getElementById("wB_L"),
          document.getElementById("wB_R"),
          document.getElementById("wB_to_AND1"),
          document.getElementById("dB"),
          document.getElementById("jB"),
        ],
        Cin: [
          document.getElementById("wCin"),
          document.getElementById("wCin_to_XOR2"),
          document.getElementById("wCin_to_AND2"),
          document.getElementById("dCin"),
        ],
        S1: [
          document.getElementById("wS1"),
          document.getElementById("wS1_to_XOR2"),
          document.getElementById("wS1_to_AND2"),
          document.getElementById("dS1"),
        ],
        C1: [document.getElementById("wC1"), document.getElementById("dC1")],
        Sum: [document.getElementById("wSum"), document.getElementById("dSum")],
        C2: [document.getElementById("wC2"), document.getElementById("dC2")],
        Cout: [
          document.getElementById("wCout"),
          document.getElementById("dCout"),
        ],
      };

      function setOnOff(els, isOn) {
        els.forEach((el) => {
          if (!el) return;
          el.classList.toggle("on", !!isOn);
        });
      }

      // ===== 真理値表生成 =====
      const rows = [];
      for (let A = 0; A <= 1; A++) {
        for (let B = 0; B <= 1; B++) {
          for (let Cin = 0; Cin <= 1; Cin++) {
            const r = fullAdderByStructure(A, B, Cin);
            rows.push({
              A,
              B,
              Cin,
              Sum: r.Sum,
              Cout: r.Cout,
              total: A + B + Cin,
            });
          }
        }
      }

      function renderTruthTable() {
        ttBody.innerHTML = "";
        rows.forEach((r, idx) => {
          const tr = document.createElement("tr");
          tr.dataset.idx = String(idx);
          tr.innerHTML = `<td>${r.A}</td><td>${r.B}</td><td>${r.Cin}</td><td>${r.Sum}</td><td>${r.Cout}</td><td>${r.total}</td>`;
          ttBody.appendChild(tr);
        });
      }

      function highlightRow(A, B, Cin) {
        const idx = rows.findIndex(
          (r) => r.A === A && r.B === B && r.Cin === Cin
        );
        [...ttBody.querySelectorAll("tr")].forEach((tr) =>
          tr.classList.remove("active")
        );
        const target = ttBody.querySelector(`tr[data-idx="${idx}"]`);
        if (target) target.classList.add("active");
      }

      // ===== 伝搬（Propagation） =====
      let propStep = 0; // 0..3
      let playing = false;
      let timerId = null;

      function setStep(n) {
        propStep = Math.max(0, Math.min(3, n));
        propStepLabel.textContent = String(propStep);
      }

      function clearTimer() {
        if (timerId !== null) {
          clearTimeout(timerId);
          timerId = null;
        }
      }

      function resetPropagation() {
        playing = false;
        clearTimer();
        setStep(0);
        update();
      }

      delayMs.addEventListener("input", () => {
        delayLabel.textContent = String(delayMs.value);
      });

      function applyPropagation(A, B, Cin, r) {
        // 全OFF
        Object.values(wires).forEach((arr) => setOnOff(arr, false));

        // 0:入力
        if (propStep >= 0) {
          setOnOff(wires.A, A);
          setOnOff(wires.B, B);
          setOnOff(wires.Cin, Cin);
        }
        // 1: XOR1/AND1（S1, C1）
        if (propStep >= 1) {
          setOnOff(wires.S1, r.S1);
          setOnOff(wires.C1, r.C1);
        }
        // 2: XOR2/AND2（Sum, C2）
        if (propStep >= 2) {
          setOnOff(wires.Sum, r.Sum);
          setOnOff(wires.C2, r.C2);
        }
        // 3: OR（Cout）
        if (propStep >= 3) {
          setOnOff(wires.Cout, r.Cout);
        }
      }

      function stepOnce() {
        setStep(propStep + 1);
        update();
        if (propStep >= 3) {
          playing = false;
          clearTimer();
        }
      }

      function loopPlay() {
        if (!playing) return;
        if (propStep >= 3) {
          playing = false;
          clearTimer();
          return;
        }
        stepOnce();

        const dt = gateDelayMsForStep(propStep) || Number(delayMs.value);
        timerId = setTimeout(loopPlay, dt);
      }

      btnStep.addEventListener("click", () => stepOnce());
      btnPlay.addEventListener("click", () => {
        if (playing) return;
        playing = true;
        clearTimer();
        if (propStep === 0) stepOnce();
        const dt = gateDelayMsForStep(propStep) || Number(delayMs.value);
        timerId = setTimeout(loopPlay, dt);
      });
      btnStop.addEventListener("click", () => {
        playing = false;
        clearTimer();
      });
      btnReset.addEventListener("click", () => resetPropagation());

      // 入力変更で伝搬リセット
      [elA, elB, elCin].forEach((el) =>
        el.addEventListener("change", () => resetPropagation())
      );

      // ===== 出力表示 =====
      function setBadge(el, v, kind) {
        el.textContent = String(v);
        el.className = "badge" + (v === 1 ? ` on ${kind}` : "");
      }

      function update() {
        const A = elA.checked ? 1 : 0;
        const B = elB.checked ? 1 : 0;
        const Cin = elCin.checked ? 1 : 0;

        binIn.textContent = `A B Cin = ${A} ${B} ${Cin}`;
        decSum.textContent = String(A + B + Cin);

        const r = fullAdderByStructure(A, B, Cin);

        setBadge(sumBadge, r.Sum, "sum");
        setBadge(coutBadge, r.Cout, "carry");

        applyPropagation(A, B, Cin, r);
        highlightRow(A, B, Cin);

        // ステップに応じて「どこを見ているか」を表示
        if (propStep === 0) {
          setActiveGate(null);
          setFlowDot(0);
        }
        if (propStep === 1) {
          setActiveGate("XOR1");
          setFlowDot(1);
        }
        if (propStep === 2) {
          setActiveGate("XOR2");
          setFlowDot(2);
        }
        if (propStep === 3) {
          setActiveGate("OR");
          setFlowDot(3);
        }
      }

      // ===== 初期化 =====
      renderTruthTable();
      delayLabel.textContent = String(delayMs.value);
      setStep(0);
      update();
    </script>
  </body>
</html>
